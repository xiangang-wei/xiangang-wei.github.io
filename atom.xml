<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>科学的超强电磁炮</title>
  
  <subtitle>点滴积累，聚沙成塔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiangang-wei.github.io/"/>
  <updated>2018-05-09T15:05:19.000Z</updated>
  <id>https://xiangang-wei.github.io/</id>
  
  <author>
    <name>xiangang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用JNI（Java Native Interface）的总结</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E4%BD%BF%E7%94%A8JNI%EF%BC%88Java-Native-Interface%EF%BC%89%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/使用JNI（Java-Native-Interface）的总结/</id>
    <published>2018-05-09T15:00:27.000Z</published>
    <updated>2018-05-09T15:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><blockquote><ol><li>什么是JNI？</li><li>为什么使用JNI？</li><li>怎么使用JNI？</li><li>在IntelliJ IDEA里使用JNI</li></ol></blockquote><h2 id="什么是JNI？"><a href="#什么是JNI？" class="headerlink" title="什么是JNI？"></a>什么是JNI？</h2><p>JNI(Java Native Interface) Java本地接口，又叫Java原生接口。它允许Java调用C/C++的代码,同时也允许在C/C++中调用Java的代码。可以把JNI理解为一个桥梁，连接Java和底层。其实根据字面意思，JNI就是一个介于Java层和Native层的接口，而Native层就是C/C++层面。</p><h2 id="为什么使用JNI？"><a href="#为什么使用JNI？" class="headerlink" title="为什么使用JNI？"></a>为什么使用JNI？</h2><p>一般情况下都是从Java的角度来使用JNI，也就是说在Java中调用C/C++语言来实现一些操作。所以从Java角度来说使用JNI具有以下的优点：</p><blockquote><ol><li>能够重复使用一些现成的、具有相同功能的的C/C++代码</li><li>因为C/C++是偏向底层的语言，所以使用C/C++能够更加的高效，而且也使得Java能够访问操作系统中一些底层的特性。</li></ol></blockquote><h2 id="怎么使用JNI？"><a href="#怎么使用JNI？" class="headerlink" title="怎么使用JNI？"></a>怎么使用JNI？</h2><p><em>这里所说的使用JNI是指从Java层调用C/C++代码，一般的使用步骤都是使用Java定义一个类，然后在该类中声明一个native的方法，接着使用C/C++来实现这个方法的方法体。</em></p><h3 id="使用Java声明native方法"><a href="#使用Java声明native方法" class="headerlink" title="使用Java声明native方法"></a>使用Java声明native方法</h3><p><strong>方法一：</strong>TestJNI.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class TestJNI&#123;</span><br><span class="line">public native void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明native方法的时候还可以规定具体的包，例如：</p><p><strong>方法二：</strong>TestJNI.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package jnilib;</span><br><span class="line">public class TestJNI&#123;</span><br><span class="line">public native void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式都可以，但是使用这两种方式声明native方法，最后生成的动态库时，在IntelliJ IDEA中的使用方法却是不一样（这一点在最后会进行说明），这里我们采用方法二。</p><h3 id="编译声明的Java文件"><a href="#编译声明的Java文件" class="headerlink" title="编译声明的Java文件"></a>编译声明的Java文件</h3><p>先使用<code>javac</code>编译生成<code>.class</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . TestJNI.java</span><br></pre></td></tr></table></figure><p>因为在源码中使用了package的命令，所以编译的时候需要用”-d .”参数，其中”.”表示在当前目录生成    <strong>jnilib文件夹</strong>来存放编译生成<code>.class</code>文件</p><p>再使用<code>javah</code>编译生成<code>.h</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah jnilib.TestJNI</span><br></pre></td></tr></table></figure><p>需要在类文件名前面加上包名，编译完成之后，会在当前目录生成<code>jnilib_TestJNI.h</code>的文件，接下来我们用C语言来实现刚刚声明的函数时，需要<code>include</code>这个头文件。</p><p>jnilib_TestJNI.h：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">/* Header for class jnilib_TestJNI */</span><br><span class="line"></span><br><span class="line">#ifndef _Included_jnilib_TestJNI</span><br><span class="line">#define _Included_jnilib_TestJNI</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Class:     jnilib_TestJNI</span><br><span class="line"> * Method:    sayHello</span><br><span class="line"> * Signature: ()V</span><br><span class="line"> */</span><br><span class="line">JNIEXPORT void JNICALL Java_jnilib_TestJNI_sayHello</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>其中 <code>JNIEXPORT void JNICALL Java_jnilib_TestJNI_sayHello(JNIEnv *, jobject);</code> 就是我们用Java声明的native函数经过转换之后的形式，当我们用C语言来实现的时候需要使用这个函数的声明。</p><p>###3.3 用C语言来实现函数<br>创建一个<code>TestJNI.c</code>文件：</p><p>TestJNI.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;jnilib_TestJNI.h&quot;</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL Java_jnilib_TestJNI_sayHello(JNIEnv *env, jobject object)&#123;</span><br><span class="line">printf(&quot;Hello World!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成动态库文件"><a href="#生成动态库文件" class="headerlink" title="生成动态库文件"></a>生成动态库文件</h3><p>这需要注意的是在不同的操作系统，能够生成的动态库文件也是不一样的，在Windows中，要生成<code>.dll</code>文件，在Linux中要生成<code>.so</code>文件，在Mac OS X中要生成<code>.jnilib</code>文件。同时定义生成的库文件名的时候也要遵循：lib+文件名＋扩展名 的原则。本例中我们在Mac OS X中所以我们定义生成的库文件为：<code>libTestJNI.jnilib</code>。</p><p>makefile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=I.</span><br><span class="line"></span><br><span class="line">libTestJNI.jnilib : TestJNI.c</span><br><span class="line">$(CC) -fPIC -I/Library/java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/include -I/Library/java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/include/darwin -shared -o $@ $^</span><br></pre></td></tr></table></figure><p>执行make之后获得 libTestJNI.jnilib其中<code>/Library/java/JavaVirtualMachines/jdk1.8.0_91.jdk</code>为Java的安装目录。</p><h3 id="使用生成的动态库文件"><a href="#使用生成的动态库文件" class="headerlink" title="使用生成的动态库文件"></a>使用生成的动态库文件</h3><p>使用Java调用生成的动态库</p><p>Demo.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import jnilib.TestJNI;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">static&#123;</span><br><span class="line">try&#123;</span><br><span class="line">System.loadLibrary(&quot;TestJNI&quot;);</span><br><span class="line">&#125;catch(UnsatisfiedLinkError e)&#123;</span><br><span class="line">System.err.println(&quot;Native code library failed to load.\n&quot; + e);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TestJNI test = new TestJNI();</span><br><span class="line">test.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译、执行后得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="在IntelliJ-IDEA里使用JNI？"><a href="#在IntelliJ-IDEA里使用JNI？" class="headerlink" title="在IntelliJ IDEA里使用JNI？"></a>在IntelliJ IDEA里使用JNI？</h2><p>利用IntelliJ IDEA创建项目，这里因为我们之前声明native函数的时候使用了package，所以我们需要在src/main/java的目录下创建一个文件夹为jnilib，把我们之前生成的<code>TestJNI.java libTest.jnilib</code> 文件放到该目录下。接着我们创建Demo文件来调用生成的动态库，但是如果我们此时运行我们的Demo的话会产生下面的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: no GetDownloadID in java.library.path</span><br></pre></td></tr></table></figure><p>这时我们需要点击<code>EditConfigurations</code>在 <code>VM Options</code> 一栏填上 <code>-Djava.library.path=&quot;/Users/xiangang/JavaWebLearning/DownloadID/src/main/java/jnilib&quot;</code>双引号里面的路径就是你刚刚创建的 <code>jnilib</code>文件夹的路径。</p><p>如果我们在声明native函数的时候没有使用package命令，则我们<strong>必须把以上的两个文件放在src/main/java目录下，而且调用这个库文件的文件也不能使用package。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;什么是JNI？&lt;/li&gt;
&lt;li&gt;为什么使用JNI？&lt;/li&gt;
&lt;li&gt;怎么使用JNI？&lt;/li&gt;
&lt;li&gt;在IntelliJ IDEA里使用JNI&lt;/li&gt;
&lt;/ol&gt;
&lt;/blo
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xiangang-wei.github.io/tags/Java/"/>
    
      <category term="JNI" scheme="https://xiangang-wei.github.io/tags/JNI/"/>
    
      <category term="C" scheme="https://xiangang-wei.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用IP地址通信时数据转发的流程</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E4%BD%BF%E7%94%A8IP%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1%E6%97%B6%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/使用IP地址通信时数据转发的流程/</id>
    <published>2018-05-09T14:58:22.000Z</published>
    <updated>2018-05-09T15:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>在复习计算机通信相关的知识的时候，有遇到一个问题：网络中两台主机A和B使用IP地址进行通信时，数据包是怎么转发的？</p><h2 id="具体的流程："><a href="#具体的流程：" class="headerlink" title="具体的流程："></a>具体的流程：</h2><ol><li><p>主机A打算通过IP地址向主机B发送信息，首先在主机A的网络层中对数据进行组装，其中：</p><blockquote><p>源IP地址：A的IP地址<br>目的IP地址：B的IP地址</p></blockquote></li><li><p>在主机A的网络层，首先判断主机B的IP地址与主机A是否时属于同一个字网，具体的做法是：主机A使用自己的字网掩码与主机B的IP地址进行“与”运算，得到的结果跟主机A的网络地址进行对比，如果相同则表示A和B属于同一子网，否则属于不同的字网。</p></li><li><p>若A和B属于同一子网，如果A知道B的MAC地址，则在主机A的数据链路层把IP数据包封装成“帧”的形式，其中：</p><blockquote><p>源MAC地址：A的MAC地址<br>目的MAC地址：B的MAC地址<br>源IP地址：A的IP地址<br>目的IP地址：B的IP地址</p></blockquote><p>如果A不知道B的MAC地址，则使用ARP协议，发送一个数据包来获取B的MAC地址，获得之后，在使用同样的方法来对IP数据包进行封装。然后直接发给主机B，至此完成数据传输。<br>若A和B属于不同的子网，A会使用ARP协议发送一个ARP数据包来获取与A相连      接的路由器1的MAC地址，之后再在数据链路层对IP数据包进行封装，其中：</p><blockquote><p>源MAC地址：A的MAC地址<br>目的MAC地址：路由器1的MAC地址<br>源IP地址：A的IP地址<br>目的IP地址：B的IP地址</p></blockquote><p>然后再把封装好的数据帧发送给与A相连接的网关1.</p></li><li><p>路由器1收到来自内部主机A的数据帧后，知道主机A希望自己转发这个数据帧，于是它就查找自己的路由表，路由器的路由表可以有两种方式进行获得：一是管理员手动添加，称为静态配置，另一种是通过路由器转发的记录自动获得，称为动态配置。在路由表中查到有与目的IP地址网络地址相对应的下一个路由地址后，这里假设为路由器2，就会对来自A的数据帧进行重组，重组后：</p><blockquote><p>源MAC地址：路由器1的MAC地址<br>目的MAC地址：路由器2的MAC地址<br>源IP地址：A的IP地址<br>目的IP地址：B的IP地址</p></blockquote><p>如果在路由器1的路由表中没有找到与主机B的网络地址相关的下一个路由地址，就会把数据发送到路由表中的默认路由地址，这是重组后的数据帧中：</p><blockquote><p>源MAC地址：路由器1的MAC地址<br>目的MAC地址：默认路由的MAC地址<br>源IP地址：A的IP地址<br>目的IP地址：B的IP地址</p></blockquote></li><li><p>路由器2在接收到路由器1发来的数据后，首先进行判断目的IP地址即主机B的IP地址是不是自己的本地网络内的，如果是自己所在的子网，则不在进行转发，将接收的数据进行重新封装：</p><blockquote><p>源MAC地址：路由器2的MAC地址<br>目的MAC地址：主机B的MAC地址<br>源IP地址：A的IP地址<br>目的IP地址：B的IP地址</p></blockquote><p>其中主机B的MAC地址可以通过ARP协议获得。封装过后再发给主机B，至此数据传输完成。如果不是，所做的事情跟之前路由器1一样，对其重新进行封装后再转发。</p></li><li><p>接下来的每一跳中，经过的路由器进行转发的时候所做的工作就跟路由器2所做的工作一样，直到找到目的IP（主机B）所在的网络。</p></li></ol><h2 id="需要注意的事："><a href="#需要注意的事：" class="headerlink" title="需要注意的事："></a>需要注意的事：</h2><ul><li>沿途所经过的转发的路由器它们并不知道从主机A到主机B完整的路由路径，它们只是知道自己应该转发的下一个的路由地址。</li><li>数据包在被转发的过程中源、目的MAC地址会被修改，但是相关的IP地址不会被修改。</li><li>以上所讲的路由器也可以理解为网关。</li><li>在UNIX下可以使用命令<code>traceroute + 网址</code>来对完整的路由信息进行跟踪。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h2&gt;&lt;p&gt;在复习计算机通信相关的知识的时候，有遇到一个问题：网络中两台主机A和B使用IP地址进行通信时，数据包是怎么转发的？&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://xiangang-wei.github.io/tags/HTTP/"/>
    
      <category term="网络" scheme="https://xiangang-wei.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="IP" scheme="https://xiangang-wei.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>需要搞清楚的关于抓包的问题</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E9%9C%80%E8%A6%81%E6%90%9E%E6%B8%85%E6%A5%9A%E7%9A%84%E5%85%B3%E4%BA%8E%E6%8A%93%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/需要搞清楚的关于抓包的问题/</id>
    <published>2018-05-09T14:54:02.000Z</published>
    <updated>2018-05-09T14:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>什么是抓包？</li><li>为什么要进行抓包？</li><li>能够进行抓包的技术原理是什么？</li><li>有哪些工具可以用来辅助抓包？</li><li>主流的移动端抓包工具对比</li></ol></blockquote><h2 id="什么是抓包？"><a href="#什么是抓包？" class="headerlink" title="什么是抓包？"></a>什么是抓包？</h2><p>不同主机之间的数据通信都是通过网络来进行传输，对那些在网络上传输的数据（发送、请求的数据）进行截获、编辑、转存等操作叫做抓包。抓包可以是抓取电脑端请求的数据，还可以抓取移动端（手机APP）的数据包。</p><h2 id="为什么要进行抓包？"><a href="#为什么要进行抓包？" class="headerlink" title="为什么要进行抓包？"></a>为什么要进行抓包？</h2><p>通过对网络上传输的数据进行抓取，可以对其进行分析，对于软件的Debug很大的帮助。当然也可以通过抓取用户发送的涉及用户名和密码的数据包来获取用户的密码。</p><h2 id="能够进行抓包的技术原理是什么？"><a href="#能够进行抓包的技术原理是什么？" class="headerlink" title="能够进行抓包的技术原理是什么？"></a>能够进行抓包的技术原理是什么？</h2><p>一般情况下，数据按照各种网络协议按照一定的格式在网络上进行传输，网络上传输的数据是以帧为单位，在对需要发送的数据进行包装的时候，会把数据的接收方、发送的的地址（MAC地址、IP地址等）一起进行包装并进行发送。根据发送方和接收方的地址，会有一条数据包的传输路径，在这条路径上，发送的数据包，会经过网络上很多台主机，标准的TCP/IP协议是这样处理的：当有数据经过主机时，主机会通过存放在数据包里面的地址来进行判断，这个数据包是否是发送自己的，如果不是发给自己的，主机就不会对它进行解析，简单的进行丢弃（转发）。如果是发送给自己的，那么主机就会对其进行解析和存储。</p><p>如果想要存储那些不是发送给自己的数据包，可以把网络适配卡设置为杂乱模式。这样它就会接收经过它的每一个数据包了。</p><h2 id="有哪些工具可以用来辅助移动端数据抓包？"><a href="#有哪些工具可以用来辅助移动端数据抓包？" class="headerlink" title="有哪些工具可以用来辅助移动端数据抓包？"></a>有哪些工具可以用来辅助移动端数据抓包？</h2><ul><li>Charles</li><li>mitmproxy</li><li>Fiddler</li><li>WireShark</li><li>TcpDump</li></ul><h2 id="主流的移动端抓包工具对比"><a href="#主流的移动端抓包工具对比" class="headerlink" title="主流的移动端抓包工具对比"></a>主流的移动端抓包工具对比</h2><p>目前主流的移动端抓包工具为：TcpDump、WireShark、Fiddler， 他们的对比如下。</p><h3 id="TcpDump："><a href="#TcpDump：" class="headerlink" title="TcpDump："></a>TcpDump：</h3><p>Android平台下的网络数据抓包工具，Android模拟器中自带 TcpDump 文件。<br>用 TcpDump 对网络数据抓包，手机不用走代理——将网络数据包添加到 WireShark 中分析即可。</p><p><strong>缺点：</strong></p><ol><li>手机必须获取 root权限；</li><li>不能查看实时通信数据——因为抓取的是 dump出来的文件，而不能实时数据交互；<br>获取的数据很多，分析时需要过滤、只查看真正有用的信息。</li></ol><h3 id="WireShark："><a href="#WireShark：" class="headerlink" title="WireShark："></a>WireShark：</h3><p>PC端截获、分析通过该网卡的所有网络通信的数据包（针对移动端时候，就要对移动端设置 代理服务器）强大的工具，完整查看网络中的每层、每个协议、每个数据包的详细组成信息；TCP、UDP、HTTP、HTTPS等协议的数据包均可获取；</p><p><strong>缺点：</strong></p><ol><li>获取的信息太多，需要手动过滤、进行分析。</li><li>只能查看，不能修改、重发送网络数据包。</li></ol><h3 id="Fiddler："><a href="#Fiddler：" class="headerlink" title="Fiddler："></a>Fiddler：</h3><p>HTTP协议的代理工具，抓取、分析电脑中所有进出该网卡、与网络进行数据交互的数据（针对移动端抓包时，需要设置代理服务器)，主要针对的是 HTTP/HTTPS协议；能够清晰查看 数据包 中的内容——HTTPS中的数据包可以解密出来；</p><p><strong>优点：</strong></p><ol><li>简单易操作，选中后即可修改Response结果</li><li>所见即所得，修改后马上可以看到效果</li></ol><p><strong>缺点：</strong></p><ol><li>只适用于一次请求，下次请求需要重新设定</li><li>手动修改需要花费时间，如果程序等待超时，本次设定的Response结果失效</li></ol><h2 id="参考网站："><a href="#参考网站：" class="headerlink" title="参考网站："></a>参考网站：</h2><p><a href="http://baike.baidu.com/view/558624.htm" target="_blank" rel="noopener">百度百科</a></p><p><a href="http://hanks.xyz/2015/11/26/%E5%88%A9%E5%99%A8_--_%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">利器 – 抓包工具总结</a></p><p><a href="http://blog.csdn.net/xsj362233248/article/details/46913699" target="_blank" rel="noopener">移动端网络数据抓包工具对比分析</a></p><p><a href="http://zqsmm.qiniucdn.com/data/20151201120046/index.html" target="_blank" rel="noopener">fiddler和wireshark工具介绍及对比 - catherine的心路历程 - 博客大巴</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;什么是抓包？&lt;/li&gt;
&lt;li&gt;为什么要进行抓包？&lt;/li&gt;
&lt;li&gt;能够进行抓包的技术原理是什么？&lt;/li&gt;
&lt;li&gt;有哪些工具可以用来辅助抓包？&lt;/li&gt;
&lt;li&gt;主流的移动端抓包工具对比&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://xiangang-wei.github.io/tags/HTTP/"/>
    
      <category term="网络" scheme="https://xiangang-wei.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="抓包" scheme="https://xiangang-wei.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>对于Java Web中的Filter和Interceptor的理解</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E5%AF%B9%E4%BA%8EJava-Web%E4%B8%AD%E7%9A%84Filter%E5%92%8CInterceptor%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/对于Java-Web中的Filter和Interceptor的理解/</id>
    <published>2018-05-09T14:48:08.000Z</published>
    <updated>2018-05-09T14:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>写在前面：因为部门项目中有用户登录验证方面的需求，故而学习了一下相关的验证技术，本文仅是作者个人学习的心得，由于水平有限，如有错误之处还请指出、见谅。</em></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p> 在设计web应用的时候，用户登录/注册是必不可少的功能，对用户登录信息进行验证的方法也是多种多样，大致可以认为如下模式：前端验证+后台验证。根据笔者的经验，一般会在前端进行一些例如是否输入数据、输入的数据的格式是否正确等一系列的验证，在后台会查询数据库进行验证。<br>一般在后台进行验证的时候，都会选择使用Servlet的Filter作为拦截器，本文主要介绍Servlet的Filter，然后再拿它跟Spring MVC的HnadlerInterceptor进行对比。</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><h5 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h5><p>Servlet作为Java Web的基础，它的一个比较核心也被广泛应用的功能就是Filter，又叫拦截器。顾名思义，拦截器就是起到拦截作用的。一般情况下，用户从客户端发出请求到服务器后，整个的流程是：</p><blockquote><p>HttpRequest —-&gt; Filter —-&gt; Servlet —-&gt; Controller/Action/… —-&gt; Filter —-&gt; HttpResponse</p></blockquote><p>根据上面的流程可以看出，Filter的作用就是在用户请求到达Servlet之前，进行拦截。在拦截到用户的请求后，我们可以实现一些自定义的业务逻辑，例如之前说到的对用户登录信息进行验证。Filter还可以在服务器响应到达客户端之前对响应的数据进行修改，本文主要介绍第一个功能。</p><h5 id="Filter的工作原理"><a href="#Filter的工作原理" class="headerlink" title="Filter的工作原理"></a>Filter的工作原理</h5><p>Filter跟Servlet一样都是由服务器负责创建和销毁的，在web应用程序启动时，服务器会根据应用程序的web.xml文件中的配置信息调用<code>public void init(FilterConfig filterConfig) throws ServletException</code>方法来初始化Filter，在web应用程序被移除或者是服务器关闭时，会调用<code>public void destroy()</code>来销毁Filter。在一个应用程序中一个Filter只会被创建和销毁一次，在进行完初始化之后，Filter中声明了<code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException</code>方法，用来实现一些需要在拦截完成之后的业务逻辑。<br>注意到上面的<code>doFilter()</code>方法的参数中，有<code>chain</code>这个参数，它是传递过来的拦截链对象，里面包含了用户定义的一系列的拦截器，这些拦截器根据其在web.xml中定义的顺序依次被执行。当用户的信息验证通过或者当前拦截器不起作用时，我们可以执行<code>chain.doFilter()</code>方法来跳过当前拦截器来执行拦截器链中的下一个拦截器。</p><h5 id="自己实现Filter"><a href="#自己实现Filter" class="headerlink" title="自己实现Filter"></a>自己实现Filter</h5><p>自己实现Filter时，需要继承接口<code>javax.servlet.Filter</code>并且实现相关的方法。</p><h6 id="所用到的工具："><a href="#所用到的工具：" class="headerlink" title="所用到的工具："></a>所用到的工具：</h6><p> IDE: IntelliJ IDEA<br> 构建工具：gradle<br> 本地服务器：Tomcat</p><h6 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h6><p><code>build.gradle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">group &apos;xiangang.wei&apos;</span><br><span class="line">version &apos;1.0-SNAPSHOT&apos;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line">apply plugin: &apos;war&apos;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123;   </span><br><span class="line">    jcenter()    </span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;   </span><br><span class="line">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.11&apos;    </span><br><span class="line">    // servlet-api    </span><br><span class="line">    compile group: &apos;javax.servlet&apos;, name: &apos;servlet-api&apos;, version: &apos;2.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>web.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;               </span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           </span><br><span class="line">xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        </span><br><span class="line">                    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;    </span><br><span class="line">&lt;filter&gt;        </span><br><span class="line">  &lt;filter-name&gt;loginValidation&lt;/filter-name&gt;      </span><br><span class="line">  &lt;filter-class&gt;filter.LoginValidation&lt;/filter-class&gt;</span><br><span class="line">  &lt;init-param&gt;            </span><br><span class="line">    &lt;param-name&gt;redirectPath&lt;/param-name&gt;            </span><br><span class="line">    &lt;param-value&gt;/index.jsp&lt;/param-value&gt;        </span><br><span class="line">  &lt;/init-param&gt;        </span><br><span class="line">  &lt;init-param&gt;            </span><br><span class="line">    &lt;param-name&gt;disableloginValidation&lt;/param-name&gt;            </span><br><span class="line">    &lt;param-value&gt;N&lt;/param-value&gt;        </span><br><span class="line">  &lt;/init-param&gt;        </span><br><span class="line">  &lt;init-param&gt;            </span><br><span class="line">    &lt;param-name&gt;logonString&lt;/param-name&gt;            </span><br><span class="line">    &lt;param-value&gt;/index.jsp&lt;/param-value&gt;        </span><br><span class="line">  &lt;/init-param&gt;    </span><br><span class="line">  &lt;/filter&gt;    </span><br><span class="line">  &lt;filter-mapping&gt;        </span><br><span class="line">    &lt;filter-name&gt;loginValidation&lt;/filter-name&gt;        </span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   </span><br><span class="line">   &lt;/filter-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p><p>web.xml中<init-param>标签被用来配置Filter的初始化时使用的参数，其中<param-name>标签表示参数的名字，可以是自己定义的任何名字，<param-value>标签表示对应的初始化参数的值。上面的初始化参数中，<code>redirectPath</code>定义了当验证不成功时页面重定向的的路径，<code>logonString</code>定义了拦截器拦截的指定URL。<code>&lt;filter-mapping&gt;</code>标签定义了拦截器的拦截模式，在<code>&lt;url-pattern&gt;</code>标签定义了拦截模式，上面的<code>/*</code>表示拦截所有。它和之前定义的指定拦截的URL标签结合起来使用。</param-value></param-name></init-param></p><p> <code>index.jsp</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--  </span><br><span class="line">Created by IntelliJ IDEA.  </span><br><span class="line">User: xiangang  </span><br><span class="line">Date: 2016/11/21  </span><br><span class="line">Time: 下午3:42  </span><br><span class="line">To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;    </span><br><span class="line">    &lt;title&gt;用户登陆界面&lt;/title&gt;   </span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;        </span><br><span class="line">      div&#123;            </span><br><span class="line">              margin: auto;            </span><br><span class="line">              border: gray 1px solid;            </span><br><span class="line">              width: 70%;        </span><br><span class="line">          &#125;    </span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">      &lt;div&gt;    </span><br><span class="line">        &lt;form action=&quot;success.jsp&quot; method=&quot;post&quot;&gt;       </span><br><span class="line">         &lt;table&gt;            </span><br><span class="line">          &lt;tr&gt;                </span><br><span class="line">            &lt;td&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt;            </span><br><span class="line">          &lt;/tr&gt;            </span><br><span class="line">          &lt;tr&gt;                </span><br><span class="line">            &lt;td&gt;密   码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/td&gt;            </span><br><span class="line">          &lt;/tr&gt;            </span><br><span class="line">          &lt;tr&gt;                </span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/td&gt;                </span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/td&gt;            </span><br><span class="line">          &lt;/tr&gt;        </span><br><span class="line">        &lt;/table&gt;    </span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>Filter对应的实现类：<br><code>LoginValidation.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package filter;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/** * </span><br><span class="line">Created by xiangang on 2016/11/21. </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public class LoginValidation implements Filter&#123;    </span><br><span class="line">public FilterConfig config;    </span><br><span class="line">public static boolean isContains(String url, String[] regx)&#123;        </span><br><span class="line">boolean flag = false;        </span><br><span class="line">for (int i = 0;i&lt;regx.length;i++)&#123;            </span><br><span class="line">  if (url.indexOf(regx[i])!=-1)&#123;                </span><br><span class="line">    flag = true;                </span><br><span class="line">    return flag;            </span><br><span class="line">  &#125;        </span><br><span class="line">&#125;        </span><br><span class="line">  return flag;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">@Override    </span><br><span class="line">public void init(FilterConfig filterConfig) throws ServletException &#123;        </span><br><span class="line">  this.config = filterConfig;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">@Override    </span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        </span><br><span class="line">  HttpServletRequest httpServletRequest= (HttpServletRequest)request;        </span><br><span class="line">  HttpServletResponse httpServletResponse = (HttpServletResponse)response;        </span><br><span class="line">  String name = httpServletRequest.getParameter(&quot;name&quot;);        </span><br><span class="line">  String password = httpServletRequest.getParameter(&quot;password&quot;);        </span><br><span class="line">  String redirectPath=httpServletRequest.getContextPath()+config.getInitParameter(&quot;redirectPath&quot;);        </span><br><span class="line">  String logonString = config.getInitParameter(&quot;logonString&quot;);</span><br><span class="line">  String[] logonList = logonString.split(&quot;;&quot;);    </span><br><span class="line">   </span><br><span class="line">  if (isContains(httpServletRequest.getRequestURI(),logonList))&#123;            </span><br><span class="line">    chain.doFilter(request,response);            </span><br><span class="line">    return;        </span><br><span class="line">  &#125;</span><br><span class="line">if (&quot;Y&quot;.equals(config.getInitParameter(&quot;disableloginValidation&quot;)))&#123;            </span><br><span class="line">    chain.doFilter(request,response); </span><br><span class="line">    return;        </span><br><span class="line">  &#125;</span><br><span class="line">if (&quot;root&quot;.equals(name) &amp;&amp; &quot;admin&quot;.equals(password))&#123;            </span><br><span class="line">    chain.doFilter(request,response);</span><br><span class="line">    return;</span><br><span class="line">  &#125;else&#123; </span><br><span class="line">    httpServletResponse.sendRedirect(redirectPath); </span><br><span class="line">    return; </span><br><span class="line">   &#125; </span><br><span class="line">  &#125;   </span><br><span class="line"> </span><br><span class="line">@Override    public void destroy() &#123;</span><br><span class="line">  this.config = null;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>登录成功之后的页面：<br> <code>success.jsp</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--  </span><br><span class="line">Created by IntelliJ IDEA.  </span><br><span class="line">User: xiangang  </span><br><span class="line">Date: 2016/11/21  </span><br><span class="line">Time: 下午3:56  </span><br><span class="line">To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;    </span><br><span class="line">&lt;title&gt;登录成功！&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">欢迎！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>配置好Tomcat之后，开启应用程序：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-25006651edc94994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登陆界面"></p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-26393c9875a892a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录成功界面"></p><p>登录失败时不会跳转，仍然会停留在原页面。</p><h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h4><p>之前提到的Filter是Servlet层面的拦截器，在许多的Java Web框架中，都实现了自己的拦截器Interceptor。例如Struts2中的Interceptor、Spring MVC中的HandlerInterceptor等。相比于Filter,框架中的Interceptor的产生作用的时间和位置不一样，下面描述了应用了Spring MVC中的HandlerInterceptor的web请求流程：</p><blockquote><p>HttpRequest —-&gt; DispactherServlet —-&gt; HandlerInterceptor —-&gt;Controller—-&gt; HandlerInterceptor —-&gt; HttpResponse</p></blockquote><p>两者的主要区别在于Filter起作用的时机是在请求到达Servlet之前，二HandlerInterceptor其作用的时机是在DispactherServlet接收到用户请求完成请求到相应的Handler映射之后。虽然都先于在具体的业务逻辑执行，但是还是存在一些差异。Filter面对的是所有的请求，而HandlerInterceptor是面对具体的Controller。Filter总是先于HandlerInterceptor发挥作用，在Filter中甚至可以中断请求，从而使它无法到达相应的Servlet。而且两者的配置也不一样，Filter是在web.xml中进行配置，HandlerInterceptor是在具体的applicationContext.xml中进行配置。</p><h5 id="HandlerInterceptor的工作原理"><a href="#HandlerInterceptor的工作原理" class="headerlink" title="HandlerInterceptor的工作原理"></a>HandlerInterceptor的工作原理</h5><p>分析源码，发现HandlerInterceptor接口中声明了如下几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerInterceptor &#123;  </span><br><span class="line"></span><br><span class="line">/**    </span><br><span class="line">* Intercept the execution of a handler. Called after HandlerMapping determined</span><br><span class="line">* an appropriate handler object, but before HandlerAdapter invokes the handler.    </span><br><span class="line">* &lt;p&gt;DispatcherServlet processes a handler in an execution chain, consisting    </span><br><span class="line">* of any number of interceptors, with the handler itself at the end.    </span><br><span class="line">* With this method, each interceptor can decide to abort the execution chain,    </span><br><span class="line">* typically sending a HTTP error or writing a custom response.    </span><br><span class="line">* &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; special considerations apply for asynchronous    </span><br><span class="line">* request processing. For more details see    </span><br><span class="line">* &#123;@link org.springframework.web.servlet.AsyncHandlerInterceptor&#125;.    </span><br><span class="line">* @param request current HTTP request    </span><br><span class="line">* @param response current HTTP response    </span><br><span class="line">* @param handler chosen handler to execute, for type and/or instance evaluation    </span><br><span class="line">* @return &#123;@code true&#125; if the execution chain should proceed with the    </span><br><span class="line">* next interceptor or the handler itself. Else, DispatcherServlet assumes    </span><br><span class="line">* that this interceptor has already dealt with the response itself.    </span><br><span class="line">* @throws Exception in case of errors    </span><br><span class="line">*/   </span><br><span class="line"></span><br><span class="line">boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;  </span><br><span class="line"> </span><br><span class="line">/**   </span><br><span class="line">* Intercept the execution of a handler. Called after HandlerAdapter actually    </span><br><span class="line">* invoked the handler, but before the DispatcherServlet renders the view.    </span><br><span class="line">* Can expose additional model objects to the view via the given ModelAndView.    </span><br><span class="line">* &lt;p&gt;DispatcherServlet processes a handler in an execution chain, consisting    </span><br><span class="line">* of any number of interceptors, with the handler itself at the end.    </span><br><span class="line">* With this method, each interceptor can post-process an execution,    </span><br><span class="line">* getting applied in inverse order of the execution chain.    </span><br><span class="line">* &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; special considerations apply for asynchronous    * request processing. For more details see    </span><br><span class="line">* &#123;@link org.springframework.web.servlet.AsyncHandlerInterceptor&#125;.    </span><br><span class="line">* @param request current HTTP request    </span><br><span class="line">* @param response current HTTP response    </span><br><span class="line">* @param handler handler (or &#123;@link HandlerMethod&#125;) that started asynchronous    </span><br><span class="line">* execution, for type and/or instance examination    </span><br><span class="line">* @param modelAndView the &#123;@code ModelAndView&#125; that the handler returned    </span><br><span class="line">* (can also be &#123;@code null&#125;)    </span><br><span class="line">* @throws Exception in case of errors    </span><br><span class="line">*/   </span><br><span class="line"></span><br><span class="line">void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;   </span><br><span class="line"></span><br><span class="line">/**    </span><br><span class="line">* Callback after completion of request processing, that is, after rendering    </span><br><span class="line">* the view. Will be called on any outcome of handler execution, thus allows    </span><br><span class="line">* for proper resource cleanup.   </span><br><span class="line">* &lt;p&gt;Note: Will only be called if this interceptor&apos;s &#123;@code preHandle&#125;    </span><br><span class="line">* method has successfully completed and returned &#123;@code true&#125;!    </span><br><span class="line">* &lt;p&gt;As with the &#123;@code postHandle&#125; method, the method will be invoked on each    </span><br><span class="line">* interceptor in the chain in reverse order, so the first interceptor will be    </span><br><span class="line">* the last to be invoked.    </span><br><span class="line">* &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; special considerations apply for asynchronous    </span><br><span class="line">* request processing. For more details see    </span><br><span class="line">* &#123;@link org.springframework.web.servlet.AsyncHandlerInterceptor&#125;.    </span><br><span class="line">* @param request current HTTP request    </span><br><span class="line">* @param response current HTTP response    </span><br><span class="line">* @param handler handler (or &#123;@link HandlerMethod&#125;) that started asynchronous    </span><br><span class="line">* execution, for type and/or instance examination    </span><br><span class="line">* @param ex exception thrown on handler execution, if any    </span><br><span class="line">* @throws Exception in case of errors    </span><br><span class="line">*/   </span><br><span class="line"></span><br><span class="line">void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三个方法分别会在具体的HandlerController方法执行之前，执行成功之后，和执行完成之后被执行。</p><h5 id="自己实现HandlerInterceptor"><a href="#自己实现HandlerInterceptor" class="headerlink" title="自己实现HandlerInterceptor"></a>自己实现HandlerInterceptor</h5><p>Spring MVC框架采用了适配器的开发模式，使用一个抽象的类<code>HandlerInterceptorAdapter</code>实现<code>HandlerInterceptor</code>接口，这样当我们需要自己实现HandlerInterceptor时，我们可以继承<code>HandlerInterceptorAdapter</code>这样我们就不用全部实现这三个方法，而可以选择性的实现自己需要的方法。</p><h6 id="所用到的工具：-1"><a href="#所用到的工具：-1" class="headerlink" title="所用到的工具："></a>所用到的工具：</h6><p> IDE: IntelliJ IDEA<br> 构建工具：gradle<br> 本地服务器：Tomcat</p><h6 id="具体的代码："><a href="#具体的代码：" class="headerlink" title="具体的代码："></a>具体的代码：</h6><p><code>build.gradle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">group &apos;xiangang.wei&apos;</span><br><span class="line">version &apos;1.0-SNAPSHOT&apos;</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line">apply plugin: &apos;war&apos;source</span><br><span class="line"></span><br><span class="line">Compatibility = 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123;    </span><br><span class="line">jcenter()    </span><br><span class="line">mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;    </span><br><span class="line">testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.11&apos;    </span><br><span class="line">// servlet-api    </span><br><span class="line">compile group: &apos;javax.servlet&apos;, name: &apos;servlet-api&apos;, version: &apos;2.5&apos;    </span><br><span class="line">//spring相关    </span><br><span class="line">compile group: &apos;org.springframework&apos;, name: &apos;spring-webmvc&apos;, version: &apos;4.3.3.RELEASE&apos;    </span><br><span class="line">compile group: &apos;org.springframework&apos;, name: &apos;spring-orm&apos;, version: &apos;4.3.3.RELEASE&apos;    </span><br><span class="line">compile group: &apos;org.springframework&apos;, name: &apos;spring-aspects&apos;, version: &apos;4.3.3.RELEASE&apos;    </span><br><span class="line">compile group: &apos;org.springframework.security&apos;, name: &apos;spring-security-config&apos;, version: &apos;3.2.0.RELEASE&apos;    </span><br><span class="line">compile group: &apos;org.springframework.security&apos;, name: &apos;spring-security-taglibs&apos;, version: &apos;3.2.0.RELEASE&apos;    </span><br><span class="line">compile &apos;org.springframework.security:spring-security-web:3.2.0.RELEASE&apos;    //hibernate相关    </span><br><span class="line">compile &apos;org.hibernate:hibernate-core:4.3.6.Final&apos;    </span><br><span class="line">//mysql    </span><br><span class="line">compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.39&apos;    </span><br><span class="line">//springData    </span><br><span class="line">compile group: &apos;org.springframework.data&apos;, name: &apos;spring-data-jpa&apos;, version: &apos;1.10.3.RELEASE&apos;    </span><br><span class="line">// https://mvnrepository.com/artifact/log4j/log4j日志    </span><br><span class="line">compile group: &apos;log4j&apos;, name: &apos;log4j&apos;, version: &apos;1.2.17&apos;   </span><br><span class="line">//json解析相关    </span><br><span class="line">compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-databind&apos;, version: &apos;2.5.4&apos;    </span><br><span class="line">compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-core&apos;, version: &apos;2.5.4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>web.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;           </span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           </span><br><span class="line">xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        </span><br><span class="line">http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;           version=&quot;3.0&quot;&gt;    </span><br><span class="line">&lt;!--框架默认帮我们配置好了ApplicationContext的实现类(org.springframework.web.context.support.XmlWebApplicationContext),不需要自己手动配置--&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--配置ApplicationContext需要加载的配置文件--&gt;    </span><br><span class="line">&lt;context-param&gt;        </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;       </span><br><span class="line">&lt;param-value&gt;classpath:databaseAccess.xml,classpath:service.xml&lt;/param-value&gt;    </span><br><span class="line">&lt;/context-param&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--ApplicationContext的加载和关闭--&gt;    </span><br><span class="line">&lt;listener&gt;        </span><br><span class="line">&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    </span><br><span class="line">&lt;/listener&gt;    </span><br><span class="line">&lt;!--配置字符过滤器,防止出现中文乱码--&gt;    </span><br><span class="line">&lt;filter&gt;        </span><br><span class="line">&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        </span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        </span><br><span class="line">&lt;init-param&gt;            </span><br><span class="line">&lt;param-name&gt;encoding&lt;/param-name&gt;            </span><br><span class="line">&lt;param-value&gt;utf-8&lt;/param-value&gt;        </span><br><span class="line">&lt;/init-param&gt;    </span><br><span class="line">&lt;/filter&gt;    </span><br><span class="line">&lt;filter-mapping&gt;        </span><br><span class="line">&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        </span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;    </span><br><span class="line">&lt;/filter-mapping&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--配置Spring MVC的前置控制器--&gt;    </span><br><span class="line">&lt;servlet&gt;        </span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        </span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        </span><br><span class="line">&lt;init-param&gt;            </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            </span><br><span class="line">&lt;param-value&gt;classpath:dispatcherServlet.xml&lt;/param-value&gt;        </span><br><span class="line">&lt;/init-param&gt;        </span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    </span><br><span class="line">&lt;/servlet&gt;    </span><br><span class="line">&lt;servlet-mapping&gt;        </span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        </span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;    </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p><p>涉及到HandlerInterceptor的配置文件<code>dispatcherServlet.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       </span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       </span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       </span><br><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       </span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd       </span><br><span class="line">http://www.springframework.org/schema/context       </span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd       </span><br><span class="line">http://www.springframework.org/schema/mvc       </span><br><span class="line">http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--开启注解--&gt;    </span><br><span class="line">&lt;mvc:annotation-driven/&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--添加需要扫描的包--&gt;    </span><br><span class="line">&lt;context:component-scan base-package=&quot;ims&quot; use-default-filters=&quot;false&quot;&gt;        </span><br><span class="line">&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    </span><br><span class="line">&lt;/context:component-scan&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--添加HandlerInterceptor--&gt;    </span><br><span class="line">&lt;mvc:interceptors&gt;        </span><br><span class="line">&lt;mvc:interceptor&gt;            </span><br><span class="line">&lt;mvc:mapping path=&quot;/user/**&quot;/&gt;            </span><br><span class="line">&lt;bean class=&quot;ims.handlerInterceptor.LoginInterceptor&quot;/&gt;        </span><br><span class="line">&lt;/mvc:interceptor&gt;        </span><br><span class="line">&lt;mvc:interceptor&gt;            </span><br><span class="line">&lt;mvc:mapping path=&quot;/register/**&quot;/&gt;            </span><br><span class="line">&lt;bean class=&quot;ims.handlerInterceptor.RegisterInterceptor&quot;/&gt;        </span><br><span class="line">&lt;/mvc:interceptor&gt;    </span><br><span class="line">&lt;/mvc:interceptors&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--添加试图解析器--&gt;    </span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        </span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;        </span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>配置HandlerInterceptor有两种方式，一种是如上面所示，这张方式配置的HandlerInterceptor可以指定具体的拦截路径，另外一种方式是直接在<code>&lt;mvc:interceptors&gt;</code>中使用<bean>标签进行配置：<code>&lt;bean class=&quot;ims.handlerInterceptor.LoginInterceptor&quot;/&gt;</code> 按照这种方式配置的HandlerInterceptor会对所有的路径进行拦截。</bean></p><p>具体的Interceptor实现类：<br><code>LoginInterceptor.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package ims.handlerInterceptor;</span><br><span class="line">import ims.service.UserService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* Created by xiangang on 16/11/17. </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public class LoginInterceptor extends HandlerInterceptorAdapter &#123;    </span><br><span class="line"></span><br><span class="line">@Autowired    </span><br><span class="line">private UserService userService;   </span><br><span class="line"> </span><br><span class="line">@Override    </span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        </span><br><span class="line">  boolean flag = true;        </span><br><span class="line">  HttpSession session = request.getSession();        </span><br><span class="line">  if (session.getAttribute(&quot;user&quot;) == null) &#123;           </span><br><span class="line">  String userName = request.getParameter(&quot;userName&quot;);            </span><br><span class="line">  String password = request.getParameter(&quot;password&quot;);            </span><br><span class="line">  flag = userService.selectByUserName(userName, password);            </span><br><span class="line">  if (flag)&#123;                </span><br><span class="line">    session.setAttribute(&quot;user&quot;,userName);            </span><br><span class="line">    &#125;        </span><br><span class="line">  &#125;        </span><br><span class="line">  if (!flag)&#123;            </span><br><span class="line">    response.sendRedirect(&quot;index.jsp&quot;);        </span><br><span class="line">    &#125;        </span><br><span class="line">  return flag;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续的其他代码这里就不一一贴出相关代码在：<a href="https://github.com/xiangang-wei/Inteceptor" target="_blank" rel="noopener">https://github.com/xiangang-wei/Inteceptor</a></p><p>具体的运行结果这里也就不再贴图了，实现的效果跟之前的Filter是一致的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要是对自己在项目中使用的相关技术进行总结，关于这个知识点还有很多内容没有覆盖到，读者如有兴趣，可以查看相关源码进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;写在前面：因为部门项目中有用户登录验证方面的需求，故而学习了一下相关的验证技术，本文仅是作者个人学习的心得，由于水平有限，如有错误之处还请指出、见谅。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xiangang-wei.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://xiangang-wei.github.io/tags/Spring/"/>
    
      <category term="Spring MVC" scheme="https://xiangang-wei.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC+Spring框架使用log4j的学习总结</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/Spring-MVC-Spring%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8log4j%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/Spring-MVC-Spring框架使用log4j的学习总结/</id>
    <published>2018-05-09T14:45:19.000Z</published>
    <updated>2018-05-09T14:47:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为程序员在日常的开发过程中，经常会遇到各种Bug，对于这种情况，作为初学者，我之前一直是在自己觉得可能出错的地方，输出相关变量的值。这种“笨”办法对于某些简单的Bug是可以的，但是大多数情况下是不可行的，要想快速定位程序出错的位置，最好的就是查看相关的日志文件。本文主要介绍如何在我们的项目中使用log4j来记录日志。如有错误之处还请指出、见谅。</p><h3 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h3><p>Log4j是一个用Java编写的可靠，快速和灵活的日志框架（API），是Apache的一个开放源代码项目。我们可以通过使用log4j可以向我们定义的地方、按照我们指定的格式输出日志文件。<br>log4j主要由三个组件组成：</p><blockquote><p>1.logger : 负责捕获、记录日志，通过它我们可以选择记录不同优先级的日志<br>2.appender : 负责发布日志，通过它我们可以指定日志的输出地方<br>3.layout : 负责日志的格式，通过它我们可以按照我们自己定义的格式来输出日志</p></blockquote><p>下面分别对这三个组件进行展开：</p><h4 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h4><p>之前有说通过它我们可以有选择性的输出不同优先级的日志，那么日志的优先级是什么？<br>日志的优先级按照优先级从低到高，可以分为：</p><blockquote><p>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</p></blockquote><p>这其中FATAL为致命的错误，会导致程序无法运行，ERROR 为严重错误 主要是程序的错误，WARN 为一般警告，比如session丢失，INFO 为一般要显示的信息，比如登录登出，DEBUG 为程序的调试信息</p><h4 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h4><p>一般情况下，appender的常用的值可以为：</p><blockquote><ol><li>org.apache.log4j.ConsoleAppender（控制台）</li><li>org.apache.log4j.FileAppender（文件）</li><li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li><li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li></ol></blockquote><p>之前有说，appender主要是定义了日志的输出地方，如果appender的值为org.apache.log4j.FileAppender则表示将日志以文件的形式输出。</p><h4 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h4><p>layout定义了日志的输出格式，其取值可以为：</p><blockquote><ol><li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li><li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式</li><li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li><li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li></ol></blockquote><p>一般都会使用org.apache.log4j.PatternLayout，当使用org.apache.log4j.PatternLayout作为layout的取值时，可以结合具体的输出格式控制来格式化每一条记录的输出：</p><blockquote><ol><li>%c 输出所属类的全名，可在修改为 %d{Num} ,Num类名输出的维（如：”org.apache.elathen.ClassName”,%C{2}将输出elathen.ClassName)</li><li>%d 输出日志时间其格式为 %d{yyyy-MM-dd HH:mm:ss,SSS}，可指定格式 如 %d{HH:mm:ss}</li><li>%l 输出日志事件发生位置，包括类目名、发生线程，在代码中的行数 </li><li>%n 换行符 </li><li>%m 输出代码指定信息，如info(“message”),输出message </li><li>%p 输出优先级，即 FATAL ,ERROR 等 </li><li>%r 输出从启动到显示该log信息所耗费的毫秒数</li><li>%t 输出产生该日志事件的线程名</li></ol></blockquote><h3 id="log4j配置"><a href="#log4j配置" class="headerlink" title="log4j配置"></a>log4j配置</h3><p>前面介绍了log4j的一些组件，看起来肯定是一头雾水，现在我们动手把log4j配置到我们的项目中。<br>在web项目中使用log4j首先要创建它的配置文件，可以是以xml文件或者是property文件的形式，本文我们使用property文件的形式。<br><code>log4j.properties</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger = info,stdout,D,E</span><br><span class="line"></span><br><span class="line">#配置stdout</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target=System.out</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125; [%p]-[%l] %m%n</span><br><span class="line"></span><br><span class="line">#配置D</span><br><span class="line">log4j.appender.D = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.D.File = /Users/xiangang/JavaWebLearning/Log4j-Test/log/log.log</span><br><span class="line">log4j.appender.D.Append = truelog4j.appender.D.Threshold = INFO</span><br><span class="line">log4j.appender.D.MaxFileSize=5MB</span><br><span class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.D.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125; [%p]-[%l] %m%n</span><br><span class="line"></span><br><span class="line">#配置E</span><br><span class="line">log4j.appender.E = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.E.File = /Users/xiangang/JavaWebLearning/Log4j-Test/log/error.log</span><br><span class="line">log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR</span><br><span class="line">log4j.appender.E.MaxFileSize=5MB</span><br><span class="line">log4j.appender.E.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.E.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125; [%p]-[%l] %m%n</span><br></pre></td></tr></table></figure></p><p>上面的配置文件是按照如下的模式来进行配置的，通常情况下，都会按照下面的格式来配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#配置根Logger</span><br><span class="line">log4j.rootLogger = [ level ] , appenderName1 , appenderName2 , …</span><br><span class="line"></span><br><span class="line">#配置日志信息输出目的地Appender</span><br><span class="line">log4j.appender.appenderName = fully.qualified.name.of.appender.class</span><br><span class="line">log4j.appender.appenderName.option1 = value1</span><br><span class="line">log4j.appender.appenderName.optionN = valueN </span><br><span class="line"></span><br><span class="line">#配置日志信息的格式layout</span><br><span class="line">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class</span><br><span class="line">log4j.appender.appenderName.layout.option1 = value1</span><br><span class="line">log4j.appender.appenderName.layout.optionN = valueN</span><br></pre></td></tr></table></figure></p><p>这里需要解释一下的是根logger<code>rootLogger</code>继承自<code>logger</code>，如果想从源码的角度分析可以参考：<a href="http://www.cnblogs.com/davidwang456/p/4243161.html" target="_blank" rel="noopener">http://www.cnblogs.com/davidwang456/p/4243161.html</a></p><p>要想使用log4j，除了配置完log4j的配置文件，还要在applicationContext初始化的时候加载它的配置文件。本文是在Spring框架中使用，所以相对来说比较简单，在web.xml中进行简单设置即可，在其他环境下使用log4j的可以参考：<a href="http://www.codeceo.com/article/log4j-usage.html" target="_blank" rel="noopener">http://www.codeceo.com/article/log4j-usage.html</a></p><p><code>web.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;           </span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           </span><br><span class="line">xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        </span><br><span class="line">http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;         version=&quot;3.0&quot;&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--设置log4j配置文件--&gt;    </span><br><span class="line">&lt;context-param&gt;       </span><br><span class="line">&lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;        </span><br><span class="line">&lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;    </span><br><span class="line">&lt;/context-param&gt;    </span><br><span class="line">&lt;!--log4j的初始化类--&gt;   </span><br><span class="line"> &lt;listener&gt;        </span><br><span class="line">&lt;listener-class&gt;</span><br><span class="line">org.springframework.web.util.Log4jConfigListener</span><br><span class="line">&lt;/listener-class&gt;    </span><br><span class="line">&lt;/listener&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--定义Filter进行用户验证--&gt;    </span><br><span class="line">&lt;filter&gt;        </span><br><span class="line">&lt;filter-name&gt;loginValidation&lt;/filter-name&gt;        </span><br><span class="line">&lt;filter-class&gt;filter.LoginValidation&lt;/filter-class&gt;        </span><br><span class="line">&lt;init-param&gt;            </span><br><span class="line">&lt;param-name&gt;logonPath&lt;/param-name&gt;            </span><br><span class="line">&lt;param-value&gt;/log4j/register.jsp;/log4j/index.jsp&lt;/param-value&gt;        </span><br><span class="line">&lt;/init-param&gt;        </span><br><span class="line">&lt;init-param&gt;            </span><br><span class="line">&lt;param-name&gt;redirectPath&lt;/param-name&gt;            </span><br><span class="line">&lt;param-value&gt;/index.jsp&lt;/param-value&gt;        </span><br><span class="line">&lt;/init-param&gt;    </span><br><span class="line">&lt;/filter&gt;    </span><br><span class="line">&lt;filter-mapping&gt;        </span><br><span class="line">&lt;filter-name&gt;loginValidation&lt;/filter-name&gt;        </span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;    </span><br><span class="line">&lt;/filter-mapping&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--配置字符过滤器,防止出现中文乱码--&gt;    </span><br><span class="line">&lt;filter&gt;        </span><br><span class="line">&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        </span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        </span><br><span class="line">&lt;init-param&gt;            </span><br><span class="line">&lt;param-name&gt;encoding&lt;/param-name&gt;            </span><br><span class="line">&lt;param-value&gt;utf-8&lt;/param-value&gt;        </span><br><span class="line">&lt;/init-param&gt;    </span><br><span class="line">&lt;/filter&gt;    </span><br><span class="line">&lt;filter-mapping&gt;        </span><br><span class="line">&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        </span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;    </span><br><span class="line">&lt;/filter-mapping&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--设置Spring MVC的前置控制器--&gt;    </span><br><span class="line">&lt;servlet&gt;        </span><br><span class="line">&lt;servlet-name&gt;DispactherServlet&lt;/servlet-name&gt;        </span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        </span><br><span class="line">&lt;init-param&gt;            </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            </span><br><span class="line">&lt;param-value&gt;classpath:dispatcherServlet.xml&lt;/param-value&gt;        </span><br><span class="line">&lt;/init-param&gt;        </span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    </span><br><span class="line">&lt;/servlet&gt;    </span><br><span class="line">&lt;servlet-mapping&gt;        </span><br><span class="line">&lt;servlet-name&gt;DispactherServlet&lt;/servlet-name&gt;        </span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;    </span><br><span class="line">&lt;/servlet-mapping&gt;    </span><br><span class="line">&lt;welcome-file-list&gt;        </span><br><span class="line">&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    </span><br><span class="line">&lt;/welcome-file-list&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p><p><code>build.gradle</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">group &apos;xiangang.wei&apos;</span><br><span class="line">version &apos;1.0-SNAPSHOT&apos;</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line">apply plugin: &apos;war&apos;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123;   </span><br><span class="line"> jcenter()    </span><br><span class="line">mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;    </span><br><span class="line">testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.11&apos;    </span><br><span class="line">// servlet-api    </span><br><span class="line">compile group: &apos;javax.servlet&apos;, name: &apos;servlet-api&apos;, version: &apos;2.5&apos;    </span><br><span class="line">// log4j api    </span><br><span class="line">compile group: &apos;log4j&apos;, name: &apos;log4j&apos;, version: &apos;1.2.17&apos;    </span><br><span class="line">//spring api    </span><br><span class="line">compile group: &apos;org.springframework&apos;, name: &apos;spring-webmvc&apos;, version: &apos;4.3.3.RELEASE&apos;    </span><br><span class="line">compile group: &apos;org.springframework&apos;, name: &apos;spring-orm&apos;, version: &apos;4.3.3.RELEASE&apos;    </span><br><span class="line">compile group: &apos;org.springframework&apos;, name: &apos;spring-aspects&apos;, version: &apos;4.3.3.RELEASE&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其余代码在：<a href="https://github.com/xiangang-wei/log4j" target="_blank" rel="noopener">https://github.com/xiangang-wei/log4j</a></p><p>配置好本地Tomcat运行后在控制台可以看到：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-4fc2e957465ba09c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制台打印的日志信息"></p><p>我们还可以在本地文件夹里看到输出的两个日志文件：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-d753d08ca5eaa870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的日志文件"></p><p>打开log.log文件：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-f79be319f8bf89eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="log.log"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为程序员在日常的开发过程中，经常会遇到各种Bug，对于这种情况，作为初学者，我之前一直是在自己觉得可能出错的地方，输出相关变量的值。这种“笨”办法对于某些简单的Bug是可以的，但是大多数情况下是不可行的，要想快速定位程序出错的位置，最好的就是查看相关的日志文件。本文主要介
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xiangang-wei.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://xiangang-wei.github.io/tags/Spring/"/>
    
      <category term="Spring MVC" scheme="https://xiangang-wei.github.io/tags/Spring-MVC/"/>
    
      <category term="log4j" scheme="https://xiangang-wei.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 项目中使用log4j统一记录异常到日志文件</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/Spring-MVC-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8log4j%E7%BB%9F%E4%B8%80%E8%AE%B0%E5%BD%95%E5%BC%82%E5%B8%B8%E5%88%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/Spring-MVC-项目中使用log4j统一记录异常到日志文件/</id>
    <published>2018-05-09T14:41:58.000Z</published>
    <updated>2018-05-09T14:44:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中有讲过在项目中使用日志的重要性，而且也总结了在Spring框架的Java Web 项目中使用log4j日志框架来记录日志的方法，如果不清楚log4j的使用方法，在阅读本文前可以前往:<a href="http://www.jianshu.com/p/6eb61fdfc5dd" target="_blank" rel="noopener">http://www.jianshu.com/p/6eb61fdfc5dd</a> 进行了解。</p><h3 id="1-不在项目中使用统一的异常处理"><a href="#1-不在项目中使用统一的异常处理" class="headerlink" title="1. 不在项目中使用统一的异常处理"></a>1. 不在项目中使用统一的异常处理</h3><p>一般情况下，我们在项目中遇到的异常可以分为：</p><blockquote><ol><li>代码进行编译时产生的异常</li><li>项目在实际运行时遇到的异常</li></ol></blockquote><p>对于前者，我们可以在项目的开发阶段时进行定位和解决，但是对于后者，我们要想定位异常，通常都会去服务器（例如Tomcat）的log日志中寻找。但是这种方法并不方便，试想如果你的服务器中部署了多个Web应用程序，那么关于这些应用程序的所有的日志都集中在一起，那么当应用程序出现问题时，寻找起来势必是非常的费力。那么我们可不可以对于某个特定的应用程序，指定一个文件夹来单独存放有关于它的异常错误日志呢？答案当然是肯定的，而且借助于log4j日志框架，我们可以实现这个功能。下面的例子展示了使用log4j来记录异常的方法。（有关于log4j的具体配置请参考：<a href="http://www.jianshu.com/p/6eb61fdfc5dd）" target="_blank" rel="noopener">http://www.jianshu.com/p/6eb61fdfc5dd）</a><br>我们在可能出现异常的地方使用try…catch的方法来抛出和处理异常。<br>我们可以在Service层类中可能出现异常的地方使用try…catch：<br><code>ValidateName.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* Created by xiangang on 2016/11/25. </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ValidateName &#123;   </span><br><span class="line">  private static final Logger logger = Logger.getLogger(ValidateName.class);    </span><br><span class="line">  public boolean validation(String name) &#123;        </span><br><span class="line">    boolean flag = false;       </span><br><span class="line">    //故意设置为空，以便抛出异常        </span><br><span class="line">    String storedName = null;        </span><br><span class="line"></span><br><span class="line">    //使用try..catch        </span><br><span class="line">    try &#123;            </span><br><span class="line">      if (storedName.equals(name))&#123;                </span><br><span class="line">        flag = true;               </span><br><span class="line">        return flag;            </span><br><span class="line">      &#125;else &#123;                </span><br><span class="line">        return flag;            </span><br><span class="line">      &#125;        </span><br><span class="line">    &#125;catch (Exception e)&#123;            </span><br><span class="line">      logger.error(&quot;错误信息&quot;,e);            </span><br><span class="line">      return flag;        </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写对应的JSP页面，编辑log4j的配置文件，在相关的Controller里面调用Service层中的这个方法，配置本地服务器，运行。可以在指定的日志文件里发现程序出错的信息：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-f8abee14f1e10661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序运行错误日志"></p><p>通过阅读日志我们可以很清楚的定位程序出错的位置。这样是可以解决我们的问题，但是通过这种方法来输出错误日志时会带来代码冗余，降低代码的可读性，影响程序的执行速度。而且对于有些代码我们在编写的时候并不知道是否会出现异常。试想如果我们要在没有个可能出错的地方使用try…catch语句手动的记录日志，那么一个项目中有这么多的业务逻辑的代码，如此一来，整个项目的代码量势必会增加很多，被这不是一个很好的方法。其实我们通过使用Spring MVC的异常统一处理器就能很好的解决这个问题。</p><h3 id="2-使用Spring-MVC的统一异常处理器"><a href="#2-使用Spring-MVC的统一异常处理器" class="headerlink" title="2. 使用Spring MVC的统一异常处理器"></a>2. 使用Spring MVC的统一异常处理器</h3><p>Spring MVC定义了异常的统一处理机制，其工作原理是：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-a86bd226afadb8f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring MVC统一异常处理流程.png"></p><p>不管是应用程序的哪里出现异常，都向上层抛出异常，最后异常被提交到Spring MVC的Dispatcher Servlet中，Dispatcher Servlet在调用系统统一的异常处理器来处理异常。</p><p>借助Spring MVC的异常处理机制，我们通过实现HandlerExceptionResolver接口来定义我们自己的异常处理器，然后在异常处理器里使用log4j对所有的异常进行统一的处理，这样我们就不需要向上面一样在每个可能出现异常的地方都是用try..catch来记录异常。</p><p>实现自己的异常处理器：<br><code>MyExceptionHandler.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package exceptionHandler;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">import org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* Created by xiangang on 2016/11/25. </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public class MyExceptionHandler implements HandlerExceptionResolver &#123;    </span><br><span class="line"></span><br><span class="line">  private static final Logger logger = Logger.getLogger(MyExceptionHandler.class);   </span><br><span class="line"> </span><br><span class="line"> /** </span><br><span class="line">  * 通过实现借口HandlerExceptionResolver的resolveException方法，</span><br><span class="line">  * 来完成日志的记录，而且还可以指定程序发生错误后跳转的web页面</span><br><span class="line">  */</span><br><span class="line"> @Override    </span><br><span class="line">  public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;          </span><br><span class="line">    logger.error(&quot;&quot;,ex);        </span><br><span class="line">    return new ModelAndView(&quot;error&quot;).addObject(&quot;exception&quot;,ex);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Spring MVC的配置文件里通过bean声明注册到IoC容器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">省略了其他的配置信息</span><br><span class="line">&lt;!--配置自定义异常处理类--&gt;</span><br><span class="line">&lt;bean id=&quot;handlerExceptionResolver&quot; class=&quot;exceptionHandler.MyExceptionHandler&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>修改我们Service层中的方法：<br><code>ValidateName.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* Created by xiangang on 2016/11/25. </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ValidateName &#123;   </span><br><span class="line">  private static final Logger logger = Logger.getLogger(ValidateName.class);    </span><br><span class="line">  public boolean validation(String name) &#123;        </span><br><span class="line">    boolean flag = false;       </span><br><span class="line">    //故意设置为空，以便抛出异常        </span><br><span class="line">    String storedName = null;      </span><br><span class="line">  </span><br><span class="line">    if (storedName.equals(name))&#123;                </span><br><span class="line">      flag = true;               </span><br><span class="line">      return flag;            </span><br><span class="line">    &#125;else &#123;                </span><br><span class="line">      return flag;            </span><br><span class="line">    &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置发生错误时的页面：<br><code>error.jsp</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--  </span><br><span class="line">Created by IntelliJ IDEA.  </span><br><span class="line">User: xiangang  </span><br><span class="line">Date: 2016/11/25  </span><br><span class="line">Time: 下午1:40  </span><br><span class="line">To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;    </span><br><span class="line">&lt;title&gt;错误页面!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;不好意思，你请求的页面被怪兽吃掉了！&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>在相关的Controller里面调用Service层中的这个方法，配置本地服务器，运行应用程序，得到如下页面：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-d43fad37795bc831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="出现错误后的跳转页面"></p><p>对应的日志文件记录的错误日志：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-7f65960f3c29bc8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序运行出现错误的日志"></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>对于异常的统一处理还有其他的方法，本篇文章只是根据作者自己的经历而总结的一种方法，如有不当之处还请指出、见谅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的文章中有讲过在项目中使用日志的重要性，而且也总结了在Spring框架的Java Web 项目中使用log4j日志框架来记录日志的方法，如果不清楚log4j的使用方法，在阅读本文前可以前往:&lt;a href=&quot;http://www.jianshu.com/p/6eb61
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xiangang-wei.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://xiangang-wei.github.io/tags/Spring/"/>
    
      <category term="Spring MVC" scheme="https://xiangang-wei.github.io/tags/Spring-MVC/"/>
    
      <category term="log" scheme="https://xiangang-wei.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建gitlab初体验+数据备份</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAgitlab%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/使用docker搭建gitlab初体验-数据备份/</id>
    <published>2018-05-09T12:26:13.000Z</published>
    <updated>2018-05-09T14:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h1><p>作为程序员，像GitHub这种好工具是必须得十分了解的，但是有时GitHub并不能满足我们所有的需求，就如作者所在的公司，我们的代码都是商业性的产品，不可能放到GitHub的开放仓库中的，而申请GitHub私人仓库需要钱。这就陷入了尴尬的局面，那有没有一种既能具有GitHub一样的功能，又能保护隐私免费的管理工具呢？答案是肯定的，感谢程序员伟大的开源精神，我们有了GitLab!!!今天笔者在这里就跟大家分享一下自己使用docker搭建GitLab的过程吧，这其中踩了一些坑，希望看过这篇文章的人不用在踩我踩过的坑了！</p><h1 id="二-环境介绍"><a href="#二-环境介绍" class="headerlink" title="二. 环境介绍"></a>二. 环境介绍</h1><p><strong>服务器信息：</strong><br>CPU : 2<br>DISK : 30G<br>RAM : 4G<br>OS : Linux centos7-0 3.10.0-229.el7.x86_64<br><em>这里笔者使用的是自己公司的服务器，也可以使用虚拟机进行搭建</em></p><h1 id="三-搭建过程"><a href="#三-搭建过程" class="headerlink" title="三. 搭建过程"></a>三. 搭建过程</h1><p><strong>1. 安装docker</strong><br>因为我们是使用docker搭建的，所以需要先安装docker，docker支持不同的OS，具体的安装信息这里不做详细介绍，可以自己的操作系统，参考官方的安装指南进行安装。<a href="http://www.docker.io" target="_blank" rel="noopener">http://www.docker.io</a><br><strong>2. 安装GitLab及相关组件</strong><br>GitLab需要用到数据库来存储相关数据，所以需要在安装GitLab的同时安装数据库，这里使用的是postgresql和redis。我在查找相关的镜像，之后发现有很多现成的镜像，这里我使用的sameersbn镜像。但是有一点我认为不是很好的是：这个镜像没有把redis、postgresql集成到gitlab的容器里面，需要先单独pull这两个镜像run一下，然后再pull gitlab的镜像进行安装。</p><p><strong>使用如下命令分别拉取最新的镜像：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull sameersbn/redis</span><br><span class="line">docker pull sameersbn/postgresql</span><br><span class="line">docker pull sameersbn/gitlab</span><br></pre></td></tr></table></figure></p><p><strong>这里有第一个坑：因为我们默认都是从docker的官方仓库中拉去镜像，但是由于国内访问国外的网站有墙，而且速度也是十分的慢，所以需要代理。这里推荐Daocloud加速器 <a href="https://www.daocloud.io/" target="_blank" rel="noopener">https://www.daocloud.io/</a> 免费使用，但是需要先注册，登录成功后，找到加速器执行相关命令即可。笔者亲测速度明显快很多！</strong></p><p><strong>使用如下命令运行postgresql镜像：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name postgresql -d \  </span><br><span class="line">-e &apos;DB_NAME=gitlabhq_production&apos; \  </span><br><span class="line">-e &apos;DB_USER=gitlab&apos; \</span><br><span class="line">-e &apos;DB_PASS=password&apos; \  </span><br><span class="line">-e &apos;DB_EXTENSION=pg_trgm&apos; \  </span><br><span class="line">-v /home/root/opt/postgresql/data:/var/lib/postgresql \  </span><br><span class="line">sameersbn/postgresql</span><br></pre></td></tr></table></figure></p><p><strong>这里需要解释的是：</strong><br>(1). 以上是一条命令，反斜杠是为了在命令内换行方便阅读，如果不喜欢，也可以写在一行。<br>(2). <code>-e</code>后面跟的都是容器的环境参数，都是在制作镜像的时候指定好的，所以不要去改动。<br>(3). <code>-v</code>后面是添加数据卷，这样在容器退出的时候数据就不会丢失，其中             <code>/home/root/opt/postgresql/data</code>是作者自己创建的文件夹，读者可以自己自定义，后面的部分是容器内的文件路径，需要保持不变。<br>(4). 命令执行成功之后会在控制台显示一串容器的编号，可以使用命令<code>docker ps</code>查看刚刚启动的容器。</p><p><strong>使用如下命令运行redis镜像：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -d \  </span><br><span class="line">-v /home/root/opt/redis/data:/var/lib/redis \  </span><br><span class="line">sameersbn/redis</span><br></pre></td></tr></table></figure></p><p>这里跟启动postgresql一样。</p><p><strong>使用如下命令运行GitLab镜像：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run --name gitlab -d \</span><br><span class="line">--link postgresql:postgresql --link redis:redisio \</span><br><span class="line">-p 10022:22 -p 10080:80 \</span><br><span class="line">-e &apos;GITLAB_PORT=10080&apos; \</span><br><span class="line">-e &apos;GITLAB_SSH_PORT=10022&apos; \</span><br><span class="line">-e &apos;GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string&apos;\</span><br><span class="line">-e &apos;GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string&apos; \</span><br><span class="line">-e &apos;GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string&apos;\</span><br><span class="line">-e &apos;GITLAB_HOST=服务器地址&apos; \</span><br><span class="line">-e &apos;GITLAB_EMAIL=邮箱地址&apos; \</span><br><span class="line">-e &apos;SMTP_ENABLED=true&apos; \</span><br><span class="line">-e &apos;SMTP_DOMAIN=www.sina.com&apos; \</span><br><span class="line">-e &apos;SMTP_HOST=smtp.sina.com&apos; \ </span><br><span class="line">-e &apos;SMTP_STARTTLS=false&apos;  \</span><br><span class="line">-e &apos;SMTP_USER=邮箱地址&apos; \</span><br><span class="line">-e &apos;SMTP_PASS=邮箱密码&apos; \</span><br><span class="line">-e &apos;SMTP_AUTHENTICATION=login&apos; \</span><br><span class="line">-e &apos;GITLAB_BACKUP_SCHEDULE=daily&apos; \</span><br><span class="line">-e &apos;GITLAB_BACKUP_TIME=10:30&apos; \</span><br><span class="line">-v /home/root/opt/gitlab/data:/home/git/data \</span><br><span class="line">sameersbn/gitlab</span><br></pre></td></tr></table></figure></p><p><strong>这里需要解释的是：</strong><br>(1). 网上又很多教程讲关于使用docker安装GitLab，但是讲的不全面，至少我按照他们的方法安装时不能正常运行，这里是第三个坑：一定要加上如下环境参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e &apos;GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string&apos;\</span><br><span class="line">-e &apos;GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string&apos; \</span><br><span class="line">-e &apos;GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string&apos;\</span><br></pre></td></tr></table></figure></p><p>有关于这三个环境参数的含义：</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-190543bc68f94afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方的解释"><br>我个人的理解是用来进行加密的key。<br>(2). 上面有关<code>SMTP</code>的环境参数是配置邮箱的，需要填上对应的邮箱信息，我使用的是新浪邮箱，读者可以根据自己的邮箱进行填写。<br>(3). 使用GitLab需要两个端口，一个是web端口，一个是SSH端口用于push代码的所以一下代码进行端口映射和指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p 10022:22 -p 10080:80 \</span><br><span class="line">-e &apos;GITLAB_PORT=10080&apos; \</span><br><span class="line">-e &apos;GITLAB_SSH_PORT=10022&apos; \</span><br></pre></td></tr></table></figure></p><p>(4). GitLab有自带的备份，这里可以通过如下进行配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e &apos;GITLAB_BACKUP_SCHEDULE=daily&apos; \</span><br><span class="line">-e &apos;GITLAB_BACKUP_TIME=10:30&apos; \</span><br></pre></td></tr></table></figure></p><p>指定的是每天10:30进行备份。</p><p>说到这里基本上GitLab就搭建好了，<strong>这里还有一个小坑就是：运行这些容器的时候可以把代码写进shell脚本中，然后通过脚本进行运行，不然直接在终端打的话很麻烦。</strong></p><p>一下就是笔者安装完后的截图，直接访问：http://服务器地址:10080  即可，首次访问可能会出现错误页面，刷新几下页面就可以了然后在修改密码默认用户名：root  之后就可以正常使用。</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-db5b5b3d456f922b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录界面"></p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-5bd5429d6c93a5e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="group"></p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-a1ef54d062715570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="admin area"></p><h1 id="四-备份"><a href="#四-备份" class="headerlink" title="四. 备份"></a>四. 备份</h1><p>我们可以使用GitLab自带的备份功能，在启动容器的时候就进行设置，然后再使用GitLab的  <code>app:rake gitlab:backup:restore</code>命令进行恢复，这里网上的教程都有说明可以参考以下网站：<br>sameersbn的GitHub wiki：<br><a href="https://github.com/sameersbn/docker-gitlab#automated-backups" target="_blank" rel="noopener">https://github.com/sameersbn/docker-gitlab#automated-backups</a><br>这个是官方的所以比较全面，里面还有关于各种环境参数的介绍。</p><p><strong>这里作者使用的是如下的备份方法：</strong><br>因为我们在运行postgresql、redis和GitLab的时候都使用了本地的文件夹进行了数据的持久化，而且我们实际需要备份的数据都在本地了，那么其实就可以直接使用<code>rsync</code>命令备份本地的这些卷（刚刚的文件夹）即可，无需再去深入到GitLab内部。如果搭建的GitLab崩溃了，或者服务器崩溃了，直接再使用docker再搭一个，在把刚刚的卷跟对应的postgresql、redis和GitLab内的数据文件夹进行映射即可。这是也不需要修改之前的启动命令，十分的方便而且作者自己测试过，发现能够达到要求，原先的仓库、用户的SSH信息等都在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-背景&quot;&gt;&lt;a href=&quot;#一-背景&quot; class=&quot;headerlink&quot; title=&quot;一. 背景&quot;&gt;&lt;/a&gt;一. 背景&lt;/h1&gt;&lt;p&gt;作为程序员，像GitHub这种好工具是必须得十分了解的，但是有时GitHub并不能满足我们所有的需求，就如作者所在的公司
      
    
    </summary>
    
    
      <category term="docker" scheme="https://xiangang-wei.github.io/tags/docker/"/>
    
      <category term="gitlab" scheme="https://xiangang-wei.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>简易的PHP Web API开发框架-simpleWebFrame</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E7%AE%80%E6%98%93%E7%9A%84PHP-Web-API%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-simpleWebFrame/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/简易的PHP-Web-API开发框架-simpleWebFrame/</id>
    <published>2018-05-09T12:19:01.000Z</published>
    <updated>2018-05-09T14:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="simpleWebFrame"><a href="#simpleWebFrame" class="headerlink" title="simpleWebFrame"></a>simpleWebFrame</h1><p>本框架是各种开发模式的基础上实现了单入口的web服务框架，可以用来开发API。<br>GitHub仓库地址：<a href="https://github.com/xiangang-wei/simpleWebFrame" target="_blank" rel="noopener">https://github.com/xiangang-wei/simpleWebFrame</a></p><h2 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h2><table><thead><tr><th>文件夹</th><th>用途</th></tr></thead><tbody><tr><td>controller</td><td>存放用户编写的处理HTTP请求的类,其中<code>Controller.php</code>为控制器基类<code>ControllerResolver.php</code>为HTTP请求映射器</td></tr><tr><td>config</td><td>文件 <code>config.php</code>存放系统的配置信息，如数据库连接信息等</td></tr><tr><td>dispatcher</td><td>统一处理接收的HTTP请求</td></tr><tr><td>public</td><td>系统入口处，系统为单一入口文件<code>index.php</code></td></tr><tr><td>registry</td><td>注册表类，提供系统配置信息、请求信息的全局访问，其中<code>ApplicationRegistry.php</code>提供系统信息，<code>RequestRegistry.php</code>提供请求信息</td></tr><tr><td>request</td><td>封装的HTTP请求</td></tr><tr><td>view</td><td>视图层文件</td></tr></tbody></table><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>从GitHub上clone本项目的代码到本地</p></li><li><p>运行<code>composer install</code></p></li><li><p>将代码部署到本地Web服务器，把<code>simpleWebFrame\public</code>设置为<code>DocumentRoot</code>。可以使用PHP内置的Web服务器快速部署验证：进入到目录<code>simpleWebFrame\public</code>，运行命令<code>php -S localhost:8000</code>，启动成功之后，打开浏览器输入网址：<code>localhost:8000</code>即可看到欢迎页面！</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/2609728-3280509eb4b75c75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="welcome.png"></p><ol start="4"><li>如果需要写新的<code>Controller</code>，在<code>controller</code>文件夹创建命名为<code>xxxController.php</code>的类即可</li></ol><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>如果在在<code>controller</code>文件夹创建命名为<code>InfoController.php</code>的类，同时在类中创建了<code>info()</code>方法，那么通过URL：<code>localhost:8000/Info/info</code>就能访问该方法 </p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前还没有视图解析器…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;simpleWebFrame&quot;&gt;&lt;a href=&quot;#simpleWebFrame&quot; class=&quot;headerlink&quot; title=&quot;simpleWebFrame&quot;&gt;&lt;/a&gt;simpleWebFrame&lt;/h1&gt;&lt;p&gt;本框架是各种开发模式的基础上实现了单入口的w
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://xiangang-wei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="PHP" scheme="https://xiangang-wei.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>从SVN迁移代码到Git实践总结</title>
    <link href="https://xiangang-wei.github.io/2018/05/09/%E4%BB%8ESVN%E8%BF%81%E7%A7%BB%E4%BB%A3%E7%A0%81%E5%88%B0Git%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://xiangang-wei.github.io/2018/05/09/从SVN迁移代码到Git实践总结/</id>
    <published>2018-05-09T12:13:18.000Z</published>
    <updated>2018-05-09T14:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Git流行起来之前，SVN是一个比较火爆的集中式的版本控制工具。但是Git作为分布式的版本控制工具，它在管理、使用等方面都比SVN要好，越来越多的公司、开发人员开始使用Git来替代SVN。这就涉及到历史代码迁移问题。当然最原始的方法就是把代码手动下载下来，然后手动创建Git仓库，再把代码push上去。这样做不仅耗费时间而且对于一些有用的信息如：原先SVN中的commit纪录等就没有了。今天借着迁移部门之前系统代码的机会，对整个过程进行总结。</p><h2 id="需要了解的背景知识"><a href="#需要了解的背景知识" class="headerlink" title="需要了解的背景知识"></a>需要了解的背景知识</h2><p>由于之前一直使用的是Git，没有接触过SVN，所以对于SVN并不是很了解，尤其是一些基础的术语的了解。也正是因为这个原因让我在往Git上迁移代码的时候遇到了一些麻烦，甚至一度卡在那里，不知道该怎么办了。</p><ul><li><p>下面简单介绍一下SVN以及一些基础的术语：</p><p>SVN的基本工作原理是在一台服务器上建立一个代码仓库，在这个仓库里面可以存放不同项目的源代码，每个用户、开发人员在使用代码仓库之前需要先把代码仓库里面的代码下载到本地（Checkout），然后用户可以在本地对代码进行修改，最后用svn命令进行提交（Commit）。整个流程跟Git的使用相差不多，只是使用的命令不同。其中刚刚介绍的创建代码仓库的服务器称为SVN服务器，用户、开发人员使用SVN客户端与SVN服务器进行交互。</p><ul><li>SVN服务器：一般分为两大种类，一类是独立的服务器，它使用SVN协议，另一类的是借助Apache服务器来实现的，它使用HTTP协议</li><li>SVN客户端：一般分为命令行和图形化工具两大类，常用的图形化工具有TortoiseSVN</li></ul></li><li><p>SVN基本命令：</p><ul><li><p>服务器端（管理员使用的）：svnadmin、 svnserve</p></li><li><p>客户端（开发人员使用的）：svn</p></li></ul></li><li><p>SVN目录</p><ul><li><p>/trunk：开发主线，相当于Git中的Master分支。</p></li><li><p>/branches：支线副本，相当于Git中的其余分支。</p></li><li><p>/tags：标签，与Git中的标签一样。</p></li></ul><p>一般的所有的开发工作都是基于trunk进行的，当一个版本开发完成，或者开发到一定段落（开发、测试、文档、制作安装程序、打包等结束后），代码基本上就处于一个稳定的状态，这是就会将代码打上tag，当下一个版本需要进行开发的时候，还会在trunk进行开发。但是此时如果发现了上一个已发行版本（Released Version）有一些bug，或者一些很急迫的功能要求，而正在开发的版本（Developing Version）无法满足时间要求，这时候就需要在上一个版本上进行修改了。解决方法是基于发行版对应的tag，做相应的分支（branch）进行开发。</p></li></ul><h2 id="从SVN到Git"><a href="#从SVN到Git" class="headerlink" title="从SVN到Git"></a>从SVN到Git</h2><p>首先需要在本地安装SVN客户端，这里由于Mac本身就支持SVN（可以在命令行下使用”svn —version”进行检测），所以我使用的是命令行的形式。若是在Windows环境下也可以下载命令行或者图形化的客户端。</p><ol><li>创建一个文件夹，使用checkout命令，从SVN服务器下载代码到本地<br><img src="http://upload-images.jianshu.io/upload_images/2609728-08797ff172081d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li><li>使用命令获取SVN用户信息，然后创建映射文件将SVN用户与Git用户进行映射</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/2609728-a208833f079cc7af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/2609728-4fe4f19a7984cfa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>将这个SVN用户与Git用户进行映射文件保存为txt格式，命名为authors.txt</p><p>3.使用git svn clone 命令从SVN服务器取回代码，并在本地创建Git仓库，同时使用之前创建的用户映射文件</p><p><img src="http://upload-images.jianshu.io/upload_images/2609728-e0a3fa6c64b3e42b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p> 这里使用git svn clone的语法为：</p><ul><li>如果SVN仓库为不标准的仓库（没有trunk、branches、tags)使用：<br><code>git svn clone --trunk=/trunk --branches=/branches --branches=/bugfixes --tags=/tags --authors-file=authors.txt &lt;svn-repo&gt;/&lt;project&gt; &lt;git-repo-name&gt;</code></li><li>如果SVN为标准仓库：<br><code>git svn clone --stdlayout --authors-file=authors.txt https://svn.atlassian.com/Confluence ConfluenceAsGit</code></li></ul><p>4.将通过<code>git svn clone</code>获得仓库，使用<code>git clone</code>当前目录 目的目录**”  命令克隆到本地其他地方，使用<code>git remote rm origin</code>去除仓库的上游</p><p>5.使用命令<code>git remote add origin xxxxx(git仓库)</code>将这个远程仓库添加到本地仓库的上游</p><p>6.使用命令<code>git push origin master</code>提交代码</p><p>至此大功告成，而且转换的Git仓库还保留着原先SVN中开发人员的提交纪录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Git流行起来之前，SVN是一个比较火爆的集中式的版本控制工具。但是Git作为分布式的版本控制工具，它在管理、使用等方面都比SVN要好，越
      
    
    </summary>
    
    
      <category term="git" scheme="https://xiangang-wei.github.io/tags/git/"/>
    
      <category term="svn" scheme="https://xiangang-wei.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xiangang-wei.github.io/2018/05/08/hello-world/"/>
    <id>https://xiangang-wei.github.io/2018/05/08/hello-world/</id>
    <published>2018-05-08T04:48:42.000Z</published>
    <updated>2018-05-09T05:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="test" scheme="https://xiangang-wei.github.io/tags/test/"/>
    
  </entry>
  
</feed>
